## 운영체제란?

하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층 

## 운영체제의 목적

### 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공

- 운영체제는 컴퓨터를 동시에 이용하는 다수의 사용자/프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환상(illusion)을 제공
- 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행


### 컴퓨터 시스템의 **자원을 효율적으로 관리**

- 실행 중인 프로그램들에게 짧은 시간씩 CPU를 번갈아 할당, 메모리 공간을 적절히 분배
- CPU, 메모리, I/O 장치 등의 효율적 관리
  - 주어진 자원으로 최대한의 성능을 내도록 -> 효율성
  - 특정 사용자/프로그램의 지나친 불이익이 발생하지 않도록 -> 형평성
- 사용자 및 운영체제 자신의 보호

## 컴퓨터 시스템의 구조
### 컴퓨터 내부
CPU, 메모리

### 컴퓨터 외부 - 입출력(I/O) 장치
디스크(보조기억장치), 키보드, 모니터, 프린터

## 운영체제의 기능
부팅이란 운영체제가 메모리에 올라가서 실행되는 것

운영체제의 핵심 부분을 커널이라고 함. 커널은 언제나 메모리에 올라와 있음

메모리에는 운영체제, 프로그램A, B, C... 등이 할당됨.

CPU의 작업공간은 메모리이기 때문에 CPU가 디스크나 외부 장치에 직접 접근할 수는 없다. I/O 장치들에는 그 장치를 전담하는 작은 CPU(I/O 컨트롤러)와 메모리가 존재. 디스크에서 파일을 읽어와야 할 경우 CPU가 디스크의 컨트롤러에게 부탁하면 컨트롤러는 자신의 메모리에 파일을 불러오고 CPU에게 완료라고 전달(이유는 아래 설명). CPU는 이를 다시 주메모리로 가져옴. 

### CPU 스케줄링

어떤 프로그램에게 CPU 사용권을 줄 것이냐. 

메모리는 CPU보다 백 배 정도 느리고, 디스크는 백만 배 정도 느리다. 디스크 읽기 작업이 필요할 때 CPU가 마냥 기다리는 것은 너무 낭비.(CPU는 놀면 안된다) 보통 CPU 사용권은 다른 프로그램에게 넘어간다. 디스크에서는 읽기 작업이 끝나면 CPU에게 자기 메모리를 읽어가라고 알려준다. 

(메모리와 CPU 간에도 속도차이가 있기 때문에 **캐시 메모리**를 둔다. )

CPU는 하드웨어라 생각하지 못한다. 그냥 가리키고 있는 위치에서 기계어를 하나 읽어와서 실행하는 것밖에 못한다. CPU가 어느 위치(프로그램)에서 읽어올지 배분하는 건 운영체제. 

사실 기본적으로 일단 CPU 사용권이 프로그램 A에게 넘어간 뒤에는 운영체제에서도 권한을 다시 빼앗아올 수 없다. 프로그램 A에서 CPU를 독점하는 것이기 때문. 특정 프로그램의 CPU의 독점을 막는 것은 운영체제만의 능력은 아니고 이를 보조하는 하드웨어가 있다. 

### 메모리 관리

한정된 메모리를 어떻게 쪼개어 쓰지?

### 디스크 스케줄링

디스크에 들어온 요청을 어떤 순서로 처리하지?

디스크도 자신에게 들어온 요청을 순서대로만 처리하면 비효율적일 수 있다. 비슷한 것이 엘리베이터. 100층 - 2층 순서로 버튼이 눌렸어도 1층부터 올라가는 길에 2층을 들리는 게 효율적. 


### 인터럽트, 캐싱

빠른 CPU와 느린 I/O 장치간 속도차이를 어떻게 극복하지? 

프로그램 A가 CPU에게 디스크 읽기를 시키면 CPU는 디스크 컨트롤러에게 읽기를 시켜놓고 (놀 수 없으니) 다른 작업을 하러 간다. 디스크에서는 작업이 끝나면 CPU에게 "작업 끝났어"라고 알려줘야 하는데 이 연락 방법이 **인터럽트**. CPU는 기계어 하나의 실행이 끝날 때마다 인터럽트 체크를 한다. 인터럽트가 들어오면 CPU는 무슨 일을 하고 있었든지 무조건 운영체제로 넘어간다. 운영체제는 인터럽트가 들어온 이유를 확인하고 CPU 스케줄을 조정한다. 

반복적으로 필요한 데이터가 있을 때 디스크에서 다시 읽어가는 것이 아니라 메모리에 저장해두고 사용하는 게 **캐싱**

## 프로세스의 상태

**프로세스**란 실행 중인 프로그램

CPU에는 **CPU 큐**가 있고, 각 **입출력 장치들에는 각각의 큐**가 존재

프로세스들은 CPU 큐에 대기하게 되고 CPU는 이를 순차적으로 실행(run)

프로세스 A에서 디스크 읽기를 요청하면 이 프로세스는 디스크의 디스크 입출력 큐로 이동되고(디스크 읽기는 느린 작업이기 때문), 디스크 읽기가 끝나면 다시 CPU 큐로 이동하게 된다. 

참고로 디스크 입출력 큐는 디스크 스케줄링에 의해 효율적으로 순서가 조정된다. (그러면 CPU 스케줄링도 CPU 큐의 순서를 바꿔주는 작업인가?)

키보드도 마찬가지. 사용자가 키보드를 두드라면 키보드 컨트롤러가 CPU에게 인터럽트를 걸고, 인터럽트가 들어왔으니 CPU는 운영체제에게 넘어가고, 운영체제는 키보드 입력으로 들어온 데이터를 메모리로 카피해서 그 프로그램이 사용할 수 있게 해줌. 

참고로 프로그램 중엔 사람과 상호작용을 하는 **Interactive Application**이 있고, 유전자 분석 같이 I/O 작업 없이 CPU 연산 위주로 이뤄진 **Scientific Application**이 있다. 


